# 架构决策记录 (Architecture Decision Records)

本文档记录 UsrLinuxEmu 项目中的重要架构决策，包括决策背景、选项分析和最终决定。

## ADR 格式

每个 ADR 包含以下部分：
- **状态**: 提议/已接受/已弃用/已替代
- **背景**: 决策背景和问题描述
- **决策**: 最终决定是什么
- **后果**: 决策的影响和权衡

---

## ADR-001: 采用用户态模拟而非内核模块

**状态**: 已接受

**日期**: 2025-12

**背景**:
设备驱动开发通常需要在内核空间进行，这带来了以下挑战：
1. 需要 root 权限
2. 需要编译和加载内核模块
3. 调试困难，容易导致系统崩溃
4. 开发周期长

**决策**:
采用用户态模拟方案，在用户空间实现 Linux 内核设备驱动框架的模拟。

**理由**:
1. **降低开发门槛**: 无需 root 权限，普通用户即可开发测试
2. **提高安全性**: 错误不会导致系统崩溃
3. **便于调试**: 可以使用标准调试工具（GDB、Valgrind 等）
4. **快速迭代**: 无需重新编译内核或重启系统
5. **跨平台潜力**: 理论上可以在非 Linux 系统上运行

**后果**:
- ✅ 极大降低了开发和测试的门槛
- ✅ 提高了开发效率和安全性
- ⚠️ 有一定的性能开销（预计 20-40%）
- ⚠️ 无法完全模拟所有内核特性
- ⚠️ 需要维护兼容层代码

---

## ADR-002: 采用 C++17 作为开发语言

**状态**: 已接受

**日期**: 2025-12

**背景**:
需要选择合适的编程语言来实现项目。主要候选语言包括 C、C++、Rust。

**决策**:
使用 C++17 作为主要开发语言。

**理由**:
1. **性能**: C++ 提供接近 C 的性能，同时有更好的抽象能力
2. **生态**: 丰富的库和工具支持
3. **面向对象**: 适合实现设备抽象和继承层次
4. **RAII**: 自动资源管理，减少内存泄漏
5. **兼容性**: 易于与现有 C 代码集成
6. **现代特性**: C++17 提供了 std::optional、std::variant 等有用特性

**为什么不选 Rust**:
- 团队熟悉度
- 与 C 库的互操作性
- 生态成熟度

**后果**:
- ✅ 良好的性能和抽象能力
- ✅ 丰富的工具和库支持
- ✅ RAII 简化资源管理
- ⚠️ 需要注意内存安全问题
- ⚠️ 编译时间较长

---

## ADR-003: 采用插件化架构

**状态**: 已接受

**日期**: 2025-12

**背景**:
项目需要支持多种设备类型，且未来可能会有新的设备类型加入。需要一个灵活的架构来支持这种扩展性。

**决策**:
采用插件化架构，设备作为动态库（.so）加载。

**理由**:
1. **松耦合**: 核心框架与具体设备实现分离
2. **可扩展**: 添加新设备无需修改核心代码
3. **模块化**: 不同设备可以独立开发和测试
4. **按需加载**: 只加载需要的设备，减少内存占用
5. **热更新**: 理论上可以在运行时更新设备实现

**实现方式**:
- 使用 dlopen/dlsym 动态加载
- 定义标准的设备工厂接口
- 通过配置文件指定要加载的插件

**后果**:
- ✅ 极好的扩展性和模块化
- ✅ 降低了模块间的耦合
- ✅ 便于第三方扩展
- ⚠️ 增加了一定的复杂度
- ⚠️ 动态加载有小的性能开销

---

## ADR-004: 使用 Buddy Allocator 管理 GPU 内存

**状态**: 已接受

**日期**: 2025-12

**背景**:
GPU 需要高效的内存管理机制，既要支持各种大小的内存分配，又要减少内存碎片。

**决策**:
使用 Buddy Allocator（伙伴分配器）算法。

**理由**:
1. **高效**: O(log n) 的分配和释放时间
2. **碎片管理**: 自动合并相邻空闲块，减少外部碎片
3. **简单**: 算法相对简单，易于实现和调试
4. **经典**: Linux 内核也使用类似算法
5. **可预测**: 性能特性清晰可预测

**替代方案考虑**:
- **Slab Allocator**: 适合固定大小对象，不适合变长分配
- **Doug Lea Allocator**: 更复杂，但灵活性更好
- **简单链表**: 太慢，碎片严重

**后果**:
- ✅ 高效的内存分配
- ✅ 良好的碎片管理
- ✅ 实现相对简单
- ⚠️ 只能分配 2 的幂次大小（有内部碎片）
- ⚠️ 需要额外的元数据空间

---

## ADR-005: 使用 Ring Buffer 管理 GPU 命令队列

**状态**: 已接受

**日期**: 2025-12

**背景**:
GPU 需要一个高效的命令队列机制，支持用户程序提交命令，模拟器消费命令。

**决策**:
使用 Ring Buffer（环形缓冲区）实现命令队列。

**理由**:
1. **高效**: 无需内存分配，预分配固定大小
2. **无锁**: 可以使用原子操作实现无锁队列
3. **简单**: 实现相对简单
4. **实时性**: 低延迟的命令传递
5. **真实性**: GPU 硬件也使用类似机制

**实现特点**:
- 生产者-消费者模式
- 使用原子操作保证线程安全
- 支持批量操作
- 提供满/空状态检测

**后果**:
- ✅ 高效的命令传递
- ✅ 良好的并发性能
- ✅ 低延迟
- ⚠️ 固定大小，可能满
- ⚠️ 需要处理环形缓冲区的边界情况

---

## ADR-006: 采用分层架构设计

**状态**: 已接受

**日期**: 2025-12

**背景**:
项目功能复杂，需要一个清晰的架构来组织代码，便于理解和维护。

**决策**:
采用四层架构：
1. 用户应用层
2. 内核模拟框架层
3. 设备驱动层
4. 硬件模拟层

**理由**:
1. **清晰的职责分离**: 每层有明确的职责
2. **低耦合**: 层与层之间通过接口交互
3. **易于理解**: 符合直觉的分层结构
4. **易于测试**: 可以独立测试每一层
5. **易于扩展**: 可以独立扩展每一层

**层次说明**:
- **用户应用层**: 用户程序，调用设备 API
- **框架层**: VFS、插件管理、服务注册等核心功能
- **驱动层**: 设备驱动实现，处理设备操作
- **模拟层**: 硬件行为模拟，执行实际操作

**后果**:
- ✅ 清晰的代码组织
- ✅ 低耦合高内聚
- ✅ 易于理解和维护
- ✅ 易于测试和扩展
- ⚠️ 可能有一定的性能开销（层间调用）

---

## ADR-007: 使用 CMake 作为构建系统

**状态**: 已接受

**日期**: 2025-12

**背景**:
需要选择合适的构建系统来管理项目编译。

**决策**:
使用 CMake 作为构建系统。

**理由**:
1. **跨平台**: 支持多种平台和编译器
2. **功能强大**: 支持复杂的构建配置
3. **生态成熟**: 大量第三方库支持 CMake
4. **现代**: 支持现代 C++ 特性
5. **集成**: 易于集成 IDE 和 CI/CD

**替代方案考虑**:
- **Make**: 太原始，不够现代
- **Meson**: 较新，生态不如 CMake 成熟
- **Bazel**: 过于复杂，学习曲线陡峭

**后果**:
- ✅ 强大的构建配置能力
- ✅ 良好的跨平台支持
- ✅ 丰富的生态系统
- ⚠️ 语法较复杂
- ⚠️ 有一定的学习曲线

---

## ADR-008: 提供 Linux 内核 API 兼容层

**状态**: 已接受

**日期**: 2026-01

**背景**:
为了让现有的 Linux 驱动代码更容易移植到 UsrLinuxEmu，需要提供 Linux 内核 API 的用户态实现。

**决策**:
实现 Linux 内核常用 API 的兼容层，放在 `include/linux_compat/` 目录。

**理由**:
1. **降低移植成本**: 现有驱动可以较少修改即可运行
2. **熟悉的接口**: 开发者可以使用熟悉的 API
3. **代码复用**: 可以复用现有的驱动代码
4. **渐进式**: 可以逐步实现，不需要一次性完成

**实现策略**:
- 优先实现常用 API（80/20 原则）
- 提供兼容性测试
- 记录与内核的差异
- 提供迁移指南

**后果**:
- ✅ 降低驱动移植成本
- ✅ 提高易用性
- ✅ 增加代码复用
- ⚠️ 增加维护负担
- ⚠️ 无法完全兼容所有 API
- ⚠️ 需要持续更新以跟进内核变化

---

## ADR-009: 采用单例模式实现核心服务

**状态**: 已接受

**日期**: 2026-01

**背景**:
某些核心服务（如 VFS、ServiceRegistry）在系统中应该只有一个实例，需要全局访问。

**决策**:
对核心服务使用单例模式。

**理由**:
1. **全局唯一**: 保证服务只有一个实例
2. **全局访问**: 任何地方都可以访问服务
3. **延迟初始化**: 可以在首次使用时初始化
4. **资源管理**: 易于管理全局资源

**实现方式**:
```cpp
class ServiceRegistry {
public:
    static ServiceRegistry& instance() {
        static ServiceRegistry inst;
        return inst;
    }
private:
    ServiceRegistry() = default;
    ServiceRegistry(const ServiceRegistry&) = delete;
    ServiceRegistry& operator=(const ServiceRegistry&) = delete;
};
```

**后果**:
- ✅ 全局唯一性保证
- ✅ 方便访问
- ✅ 资源管理清晰
- ⚠️ 增加全局状态（可能影响测试）
- ⚠️ 需要考虑线程安全

---

## ADR-010: 计划迁移到 GTest 测试框架

**状态**: 提议

**日期**: 2026-02

**背景**:
当前测试使用简单的 main 函数，缺少标准化的断言和测试组织。

**决策**:
将测试迁移到 Google Test (GTest) 框架。

**理由**:
1. **标准化**: 业界标准的 C++ 测试框架
2. **丰富的断言**: 提供各种断言宏
3. **测试组织**: 支持测试套件和固件
4. **输出友好**: 清晰的测试报告
5. **CI 集成**: 易于集成到 CI/CD

**迁移计划**:
1. 集成 GTest 到构建系统
2. 创建测试基类和工具函数
3. 逐步迁移现有测试
4. 为新功能编写 GTest 测试

**后果**:
- ✅ 标准化的测试框架
- ✅ 更好的测试组织
- ✅ 更清晰的测试报告
- ⚠️ 需要学习 GTest
- ⚠️ 迁移需要时间

---

## 未来的决策

以下是计划讨论的架构决策：

### ADR-011: 多进程支持方案（待定）
- 共享内存 vs 独立内存
- 进程间通信机制
- 资源隔离策略

### ADR-012: 性能优化策略（待定）
- 对象池
- 零拷贝
- 批量操作
- 缓存优化

### ADR-013: 错误处理策略（待定）
- 返回码 vs 异常
- 错误传播机制
- 恢复策略

### ADR-014: 日志系统增强（待定）
- 结构化日志
- 日志级别
- 日志轮转
- 性能影响

---

## 更新历史

- 2026-02-10: 初始版本，包含 ADR-001 到 ADR-010
- 待更新...

---

**维护者**: UsrLinuxEmu Architecture Team  
**最后更新**: 2026-02-10
